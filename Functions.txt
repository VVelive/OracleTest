Functions:


====================================================================================

create or replace function
   check_area_overlap
      (
      p_at1  in  varchar2,
      p_a1   in  varchar2,
      p_at2  in  varchar2,
      p_a2   in  varchar2
      )
      return boolean is
   v_rc   boolean;
   cursor c_overlap is
      select 1
      from organization_rels
      where org_type = p_at1
      and org = p_a1
      and parent_type = p_at2
      and parent = p_a2
      and relationship = 'OVERLAPS';
   c_overlap_rec c_overlap%rowtype;
begin
   if p_at1 = p_at2 then
      if p_a1 = p_a2 then
	 v_rc := TRUE;
      else
	 v_rc := FALSE;
      end if;
   else
      open c_overlap;
      fetch c_overlap into c_overlap_rec;
      if c_overlap%found then
	 v_rc := TRUE;
      else
	 v_rc := FALSE;
      end if;
      close c_overlap;
   end if;
   return(v_rc);
/* no exception handler */
   /* Since this function returns a boolean (not a number), if we have any
      errors, we let the calling function handle them. */
end;


=======================================================================================================================

create or replace function
   check_trans_batch
      (
      p_trans_type           in  char
      )
      return number is
v_rc  number;
cursor c_tb is
   select 1
   from transmission_batches
   where transmission_type = p_trans_type
   and (status_code = 'A' or status_code = 'W');
c_tb_rec c_tb%rowtype;
begin
   /* check to see if any 'W' or 'A' batches are outstanding */
   open c_tb;
   fetch c_tb into c_tb_rec;
   if c_tb%found then
      v_rc := -1;
   else
      v_rc := 0;
   end if;
   close c_tb;
   return(v_rc);
exception
   when no_data_found then
      /* this is only for "select into" */
      return(-1);
   when others then
      return(-1);
end;


===============================================================================================


create or replace function
chk_sku_listed(p_sku      in   varchar2,
    	       p_dc       in   varchar2,
    	       p_ref_date in   date)
return varchar2 is

p_rank             prod_statuses.rank%TYPE;
p_status           prod_statuses.status%TYPE;
p_reg              organization_rels.org%TYPE;

p_rec_found	   varchar2(1);

cursor reg_cur is
	select org
	from organization_rels
	where parent = p_dc
	and   parent_type = std_dc_map.get_dc_type(p_sku)
	and   org_type = 'MKR'
	and   relationship = 'INSIDE';

cursor ssh_cur is
  select ssh.status, ps.rank
  from  sku_status_histories  ssh,
	prod_statuses 	      ps
  where ssh.sku	       = p_sku
  and   ssh.reg        = p_reg
  and   ssh.status     = ps.status
  and   ssh.store_start_date = (select max(store_start_date)
			        from   sku_status_histories
			        where  sku = ssh.sku
			        and    reg = p_reg
			        and    start_date <= p_ref_date);

begin
  p_rank   := null;
  p_status := null;

  for reg_rec in reg_cur loop
    p_reg := reg_rec.org;
    for ssh_rec in ssh_cur loop
      if ssh_rec.rank < nvl(p_rank, 100) then
        p_rank   := ssh_rec.rank;
        p_status := ssh_rec.status;
	if p_rank < 5 then
	  goto end_loop;
	end if;
      end if;
    end loop;
    <<end_loop>>
    null;
  end loop;

  begin
    -- -------------------------------------
    -- return 'Y' if the product is listed,
    -- return 'N' otherwise.
    -- -------------------------------------
    select distinct 'Y'
    into   p_rec_found
    from   sku_status_attrs
    where  status = p_status
    and    attr  != 'DLS';
  exception
    when no_data_found then
      p_rec_found := 'N';
  end;

  return p_rec_found;

end;


======================================================================================================================
create or replace function get_sku_all_status
     (as_type               in varchar2,
      as_sku                in varchar2,
      a_early_whse_date     in  date,
      a_event_whse_date     in  date
      )
      return varchar2 is

ls_status              varchar2(2);
ls_all_status          varchar2(10);
ld_store_status_date   date;
ls_dc_for_reg          varchar2(1);
ls_dcx_item            varchar2(1);
ls_non_dcx_item        varchar2(1);
ls_chk_multi_whse_date varchar2(1);
ld_warehouse_date      date;
ls_reg                 varchar2(3);


cursor corp_status (as_reg in number) is
   select decode(s1.status,'C','1','O','2','T','3','Q','4',
		  'Z','5','S','6','D','7','N','8','R','9', '10')
   from   sku_status_histories s1
   where  s1.reg =  decode(as_reg,1,'ATL',2,'QUE',3,'ONT',4,'PRA','BC')
   and    s1.sku =  as_sku
   and    s1.start_date =
          (select   max(ssh.start_date)
           from     sku_status_histories ssh
           where    ssh.reg = s1.reg
           and      ssh.sku = s1.sku
           and      ssh.start_date <= ld_warehouse_date);

cursor store_status (as_reg in number, ad_store_status_date in date) is
   select decode(s1.status,'C','1','O','2','T','3','Q','4',
		  'Z','5','S','6','D','7','N','8','R','9', '10')
   from   sku_status_histories s1
   where  s1.reg =  decode(as_reg,1,'ATL',2,'QUE',3,'ONT',4,'PRA','BC')
   and    s1.sku =  as_sku
   and    to_char( store_start_date, 'YYYYMMDD' ) ||
               to_char( start_date, 'YYYYMMDD' )
                  = ( select max( to_char(store_start_date, 'YYYYMMDD') ||
                                  to_char(start_date, 'YYYYMMDD')
                                )
                      from   sku_status_histories
                      where  sku  = s1.sku
                      and    reg  = s1.reg
                      and    start_date
                                <= least( ad_store_status_date,
                                                        ld_warehouse_date )
                      and    store_start_date <= ld_warehouse_date
                    ) ;

begin
   select trunc(sysdate) + to_number(para_value)
   into   ld_store_status_date
   from   system_parameters
   where  para_key = 'STORE_STATUS_AHEAD';

   if as_type = 'C' then
     for i in 1..5 loop
       ls_chk_multi_whse_date := 'N';
       ls_dcx_item := 'N';
       ls_non_dcx_item := 'N';

       if i=1 then
          ls_reg := 'ATL';
       elsif i=2 then
          ls_reg := 'QUE';
       elsif i=3 then
          ls_reg := 'ONT';
       elsif i=4 then
          ls_reg := 'PRA';
       elsif i=5 then
          ls_reg := 'BC';
       end if;

       ls_dc_for_reg := std_promo_sku_status.is_dc_for_reg
                                           (as_sku, ls_reg, a_early_whse_date);
       if ls_dc_for_reg = 'Y' then
          ls_dcx_item := std_promo_sku_status.is_dcx_for_reg
                                     (as_sku, ls_reg, NULL, a_early_whse_date);
       end if;
       if ls_dcx_item = 'Y' then
          ls_non_dcx_item := std_promo_sku_status.is_non_dcx_for_reg
                                     (as_sku, ls_reg, NULL, a_early_whse_date);
       end if;

       if ls_dc_for_reg = 'Y' and ls_dcx_item = 'Y' then
          if ls_non_dcx_item = 'N' then
             ld_warehouse_date := a_early_whse_date;
          else
             ls_chk_multi_whse_date := 'Y';
          end if;
       else
          ld_warehouse_date := a_event_whse_date;
       end if;

       if ls_chk_multi_whse_date = 'N' then
          open corp_status(i);
          fetch corp_status into ls_status;
          if corp_status%notfound then
             ls_status := '10';
          end if;
          close corp_status;
          ls_all_status := concat(ls_all_status,ls_status);
       else
         ld_warehouse_date := a_early_whse_date;
         open corp_status(i);
         fetch corp_status into ls_status;
         if corp_status%notfound then
            ls_status := '10';
         end if;
         close corp_status;

         if ls_status < 6 then
            ls_all_status := concat(ls_all_status,ls_status);
         else
            ld_warehouse_date := a_event_whse_date;
            open corp_status(i);
            fetch corp_status into ls_status;
            if corp_status%notfound then
               ls_status := '10';
            end if;
            close corp_status;
            ls_all_status := concat(ls_all_status,ls_status);
         end if;
       end if;
     end loop;
   else
     --
     for i in 1..5 loop
       ls_chk_multi_whse_date := 'N';
       ls_dcx_item := 'N';
       ls_non_dcx_item := 'N';

       if i=1 then
          ls_reg := 'ATL';
       elsif i=2 then
          ls_reg := 'QUE';
       elsif i=3 then
          ls_reg := 'ONT';
       elsif i=4 then
          ls_reg := 'PRA';
       elsif i=5 then
          ls_reg := 'BC';
       end if;

       ls_dc_for_reg := std_promo_sku_status.is_dc_for_reg
                                           (as_sku, ls_reg, a_early_whse_date);
       if ls_dc_for_reg = 'Y' then
          ls_dcx_item := std_promo_sku_status.is_dcx_for_reg
                                     (as_sku, ls_reg, NULL, a_early_whse_date);
       end if;
       if ls_dcx_item = 'Y' then
          ls_non_dcx_item := std_promo_sku_status.is_non_dcx_for_reg
                                     (as_sku, ls_reg, NULL, a_early_whse_date);
       end if;

       if ls_dc_for_reg = 'Y' and ls_dcx_item = 'Y' then
          if ls_non_dcx_item = 'N' then
             ld_warehouse_date := a_early_whse_date;
          else
             ls_chk_multi_whse_date := 'Y';
          end if;
       else
          ld_warehouse_date := a_event_whse_date;
       end if;

       if ls_chk_multi_whse_date = 'N' then
          open store_status(i, ld_store_status_date);
          fetch store_status into ls_status;
          if store_status%notfound then
             ls_status := '10';
          end if;
          close store_status;
          ls_all_status := concat(ls_all_status,ls_status);
       else
         ld_warehouse_date := a_early_whse_date;
         open store_status(i, ld_store_status_date);
         fetch store_status into ls_status;
         if store_status%notfound then
            ls_status := '10';
         end if;
         close store_status;

         if ls_status < 6 then
            ls_all_status := concat(ls_all_status,ls_status);
         else
            ld_warehouse_date := a_event_whse_date;
            open store_status(i, ld_store_status_date);
            fetch store_status into ls_status;
            if store_status%notfound then
               ls_status := '10';
            end if;
            close store_status;
            ls_all_status := concat(ls_all_status,ls_status);
         end if;
       end if;
     end loop;
   end if;
   return ls_all_status;
end;


====================================================================================================

create or replace function
   insert_trans_file_stores
      (
      p_trans_batch_id   in  number,
      p_reg              in  varchar2,
      p_cost_only        in  number,
      p_file_build_only  in  number
      )
      return number is
begin
   /* insert into trans_file_stores from trans_files */
   /* restrict to stores within region */
   /* Not yet coded:  if p_cost_only, only 'C' records, else all */
   /* Not yet coded:  if file_build_only, restrict to file_build_stores */
   insert into trans_file_stores
      (trans_batch_id, file_number, store)
   select tf.trans_batch_id, tf.file_number, s.store
   from stores s, trans_files tf
   where tf.trans_batch_id = p_trans_batch_id
   and tf.file_type = 'C'
   and s.map_complete_flag = 'Y'
   and s.v97_date_file_build is not null
   and s.language_type = tf.lang
   and exists
      (select '1'
      from organization_rels o3
      where o3.org = s.store
      and o3.org_type = 'STR'
      and o3.parent_type = tf.cost_area_type
      and o3.parent = tf.cost_area
      and o3.relationship = 'CONTAINS')
   and exists
      (select '1'
      from organization_rels o1
      where o1.org = s.store
      and o1.org_type = 'STR'
      and o1.parent_type = tf.vend_area_type
      and o1.parent = tf.vend_area
      and o1.relationship = 'CONTAINS')
   and exists
      (select '1'
      from organization_rels o2
      where o2.org = s.store
      and o2.org_type = 'STR'
      and o2.parent_type = tf.distn_area_type
      and o2.parent = tf.distn_area
      and o2.relationship = 'CONTAINS')
   and exists
      (select '1'
      from organization_rels o4
      where o4.org = s.store
      and o4.org_type = 'STR'
      and o4.parent_type = 'MKR'
      and o4.parent = p_reg
      and o4.relationship = 'CONTAINS');
      if sql%notfound then
	 return(-1);
      else
	 return(sql%rowcount);
      end if;
exception
   when no_data_found then
      /* this is only for a "select into" */
      return(-1);
   when others then
      return(-1);
end;


====================================================================================


create or replace function
   insert_trans_files
      (
      p_trans_batch_id   in  number,
      p_cost_only        in  number
      )
      return number is
   first_fetch    boolean;
   /* Not yet coded:  if p_cost_only, only trans_costs records, else all */
   cursor c_tf_cost is
      select distinct trans_batch_id,
	     'C' file_type,
	     distn_area_type, distn_area,
	     vend_area_type, vend_area,
	     NULL src_area_type, NULL src_area,
	     cost_area_type, cost_area,
	     NULL prov, NULL zone,
	     pc.code lang
      from trans_costs tc, promo_codes pc
      where trans_batch_id = p_trans_batch_id
      and   pc.code_type = 'LAN'
      and   ( (tc.lang = 'A') or (tc.lang = pc.code) ) ;
   c_tf_cost_rec c_tf_cost%rowtype;
begin
   open c_tf_cost;
   first_fetch := TRUE;
   loop
      fetch c_tf_cost into c_tf_cost_rec;
      if c_tf_cost%notfound then
	 exit;
      end if;
      first_fetch := FALSE;
      insert into trans_files
	 (trans_batch_id, file_number,
	 file_type,
	 distn_area_type, distn_area,
	 vend_area_type, vend_area,
	 src_area_type, src_area,
	 cost_area_type, cost_area,
	 prov, zone,
	 lang)
      values
	 (c_tf_cost_rec.trans_batch_id, trans_files_file_num_seq.nextval,
	 c_tf_cost_rec.file_type,
	 c_tf_cost_rec.distn_area_type, c_tf_cost_rec.distn_area,
	 c_tf_cost_rec.vend_area_type, c_tf_cost_rec.vend_area,
	 c_tf_cost_rec.src_area_type, c_tf_cost_rec.src_area,
	 c_tf_cost_rec.cost_area_type, c_tf_cost_rec.cost_area,
	 c_tf_cost_rec.prov, c_tf_cost_rec.zone,
	 c_tf_cost_rec.lang);
      if sql%notfound then
	 return(-1);
      end if;
   end loop;
   close c_tf_cost;
   if first_fetch = TRUE then
      return(-1);
   else
      return(0);
   end if;
exception
   when no_data_found then
      /* this is only for a "select into" */
      return(-1);
   when others then
      return(-1);
end;


=========================================================================================================


create or replace function lc_sku_dc_check(p_sku in varchar2,
                                            p_dc in varchar2)
                       return varchar2 is
    l_sku_dc varchar2(1) ;

    appl                  plsql_error.appl%type;
    appl_step             plsql_error.appl_step%type;
    dml_operation         plsql_error.dml_operation%type;
    table_name            plsql_error.table_name%type;
    p_row_id              plsql_error.row_id%type;
    p_sqlcode             plsql_error.sqlcode%type;
    p_sqlerrm             plsql_error.sqlerrm%type;
    error_note            exception;

  begin

    appl := 'pm390';
    appl_step := 'Step 01';
     dml_operation := 'S';
	 table_name := 'lcl_dc_costs';

    select distinct 'Y'
      into l_sku_dc
      from lcl_dc_costs
     where sku = p_sku
	   and dc=p_dc;


    return l_sku_dc ;

  exception
      when no_data_found then return 'N' ;
      when others then p_sqlcode := sqlcode;
                  p_sqlerrm := sqlerrm; 
                  rollback;
                          insert into plsql_error ( system_id, appl,
                                                    username, dent,
                                                    tent, appl_step,
                                                    dml_operation,
                                                    table_name, row_id,
                                                    sqlcode, sqlerrm ) 
                          values ( 'PM', appl,
                                   user, sysdate,                                                      
                                   to_char(sysdate,'HH24-MI-SS'),
                                   appl_step,
                                   decode(dml_operation, 'A', 'ASSIGN',
                                                         'D', 'DELETE',
                                                         'I', 'INSERT',
                                                         'L', 'LOCK',
                                                         'S', 'SELECT',
                                                         'U', 'UPDATE' ),
                                   table_name, p_row_id,
                                   p_sqlcode, p_sqlerrm );
                          commit;
                          raise error_note;

  end lc_sku_dc_check ;
  
  
=====================================================================================================

create or replace function get_sku_all_status
     (as_type               in varchar2,
      as_sku                in varchar2,
      a_early_whse_date     in  date,
      a_event_whse_date     in  date
      )
      return varchar2 is

ls_status              varchar2(2);
ls_all_status          varchar2(10);
ld_store_status_date   date;
ls_dc_for_reg          varchar2(1);
ls_dcx_item            varchar2(1);
ls_non_dcx_item        varchar2(1);
ls_chk_multi_whse_date varchar2(1);
ld_warehouse_date      date;
ls_reg                 varchar2(3);


cursor corp_status (as_reg in number) is
   select decode(s1.status,'C','1','O','2','T','3','Q','4',
		  'Z','5','S','6','D','7','N','8','R','9', '10')
   from   sku_status_histories s1
   where  s1.reg =  decode(as_reg,1,'ATL',2,'QUE',3,'ONT',4,'PRA','BC')
   and    s1.sku =  as_sku
   and    s1.start_date =
          (select   max(ssh.start_date)
           from     sku_status_histories ssh
           where    ssh.reg = s1.reg
           and      ssh.sku = s1.sku
           and      ssh.start_date <= ld_warehouse_date);

cursor store_status (as_reg in number, ad_store_status_date in date) is
   select decode(s1.status,'C','1','O','2','T','3','Q','4',
		  'Z','5','S','6','D','7','N','8','R','9', '10')
   from   sku_status_histories s1
   where  s1.reg =  decode(as_reg,1,'ATL',2,'QUE',3,'ONT',4,'PRA','BC')
   and    s1.sku =  as_sku
   and    to_char( store_start_date, 'YYYYMMDD' ) ||
               to_char( start_date, 'YYYYMMDD' )
                  = ( select max( to_char(store_start_date, 'YYYYMMDD') ||
                                  to_char(start_date, 'YYYYMMDD')
                                )
                      from   sku_status_histories
                      where  sku  = s1.sku
                      and    reg  = s1.reg
                      and    start_date
                                <= least( ad_store_status_date,
                                                        ld_warehouse_date )
                      and    store_start_date <= ld_warehouse_date
                    ) ;

begin
   select trunc(sysdate) + to_number(para_value)
   into   ld_store_status_date
   from   system_parameters
   where  para_key = 'STORE_STATUS_AHEAD';

   if as_type = 'C' then
     for i in 1..5 loop
       ls_chk_multi_whse_date := 'N';
       ls_dcx_item := 'N';
       ls_non_dcx_item := 'N';

       if i=1 then
          ls_reg := 'ATL';
       elsif i=2 then
          ls_reg := 'QUE';
       elsif i=3 then
          ls_reg := 'ONT';
       elsif i=4 then
          ls_reg := 'PRA';
       elsif i=5 then
          ls_reg := 'BC';
       end if;

       ls_dc_for_reg := std_promo_sku_status.is_dc_for_reg
                                           (as_sku, ls_reg, a_early_whse_date);
       if ls_dc_for_reg = 'Y' then
          ls_dcx_item := std_promo_sku_status.is_dcx_for_reg
                                     (as_sku, ls_reg, NULL, a_early_whse_date);
       end if;
       if ls_dcx_item = 'Y' then
          ls_non_dcx_item := std_promo_sku_status.is_non_dcx_for_reg
                                     (as_sku, ls_reg, NULL, a_early_whse_date);
       end if;

       if ls_dc_for_reg = 'Y' and ls_dcx_item = 'Y' then
          if ls_non_dcx_item = 'N' then
             ld_warehouse_date := a_early_whse_date;
          else
             ls_chk_multi_whse_date := 'Y';
          end if;
       else
          ld_warehouse_date := a_event_whse_date;
       end if;

       if ls_chk_multi_whse_date = 'N' then
          open corp_status(i);
          fetch corp_status into ls_status;
          if corp_status%notfound then
             ls_status := '10';
          end if;
          close corp_status;
          ls_all_status := concat(ls_all_status,ls_status);
       else
         ld_warehouse_date := a_early_whse_date;
         open corp_status(i);
         fetch corp_status into ls_status;
         if corp_status%notfound then
            ls_status := '10';
         end if;
         close corp_status;

         if ls_status < 6 then
            ls_all_status := concat(ls_all_status,ls_status);
         else
            ld_warehouse_date := a_event_whse_date;
            open corp_status(i);
            fetch corp_status into ls_status;
            if corp_status%notfound then
               ls_status := '10';
            end if;
            close corp_status;
            ls_all_status := concat(ls_all_status,ls_status);
         end if;
       end if;
     end loop;
   else
     --
     for i in 1..5 loop
       ls_chk_multi_whse_date := 'N';
       ls_dcx_item := 'N';
       ls_non_dcx_item := 'N';

       if i=1 then
          ls_reg := 'ATL';
       elsif i=2 then
          ls_reg := 'QUE';
       elsif i=3 then
          ls_reg := 'ONT';
       elsif i=4 then
          ls_reg := 'PRA';
       elsif i=5 then
          ls_reg := 'BC';
       end if;

       ls_dc_for_reg := std_promo_sku_status.is_dc_for_reg
                                           (as_sku, ls_reg, a_early_whse_date);
       if ls_dc_for_reg = 'Y' then
          ls_dcx_item := std_promo_sku_status.is_dcx_for_reg
                                     (as_sku, ls_reg, NULL, a_early_whse_date);
       end if;
       if ls_dcx_item = 'Y' then
          ls_non_dcx_item := std_promo_sku_status.is_non_dcx_for_reg
                                     (as_sku, ls_reg, NULL, a_early_whse_date);
       end if;

       if ls_dc_for_reg = 'Y' and ls_dcx_item = 'Y' then
          if ls_non_dcx_item = 'N' then
             ld_warehouse_date := a_early_whse_date;
          else
             ls_chk_multi_whse_date := 'Y';
          end if;
       else
          ld_warehouse_date := a_event_whse_date;
       end if;

       if ls_chk_multi_whse_date = 'N' then
          open store_status(i, ld_store_status_date);
          fetch store_status into ls_status;
          if store_status%notfound then
             ls_status := '10';
          end if;
          close store_status;
          ls_all_status := concat(ls_all_status,ls_status);
       else
         ld_warehouse_date := a_early_whse_date;
         open store_status(i, ld_store_status_date);
         fetch store_status into ls_status;
         if store_status%notfound then
            ls_status := '10';
         end if;
         close store_status;

         if ls_status < 6 then
            ls_all_status := concat(ls_all_status,ls_status);
         else
            ld_warehouse_date := a_event_whse_date;
            open store_status(i, ld_store_status_date);
            fetch store_status into ls_status;
            if store_status%notfound then
               ls_status := '10';
            end if;
            close store_status;
            ls_all_status := concat(ls_all_status,ls_status);
         end if;
       end if;
     end loop;
   end if;
   return ls_all_status;
end;

===========================================================================================================

create or replace function lcl_dc_stream_exists(p_sku in varchar2,
 p_dc varchar2 )
 return varchar2 is
 
    l_str_exists          varchar2(1) ;
    p_sqlcode             plsql_error.sqlcode%type;
    p_sqlerrm             plsql_error.sqlerrm%type;

begin

  Select  distinct 'Y' 
    into l_str_exists
    From sku_stream_areas ssa
   Where ssa.sku= p_sku
     and ssa.dc= p_dc
     and ssa.eff_date in (select max(eff_date)
                            from sku_stream_areas ssa1
                           where ssa1.sku=ssa.sku
                             and ssa1.stream_area=ssa.stream_area
                             and ssa1.eff_date <= trunc(sysdate));


    return l_str_exists;

exception
      when no_data_found then return 'N' ;
      when others then p_sqlcode := sqlcode;
                  p_sqlerrm := sqlerrm; 
                  rollback;

end lcl_dc_stream_exists;


======================================================================================================


create or replace function
  np_chk_cas_relation
  (
    p_master_sku         in  varchar2,
    p_detail_sku         in  varchar2,
    p_master_grp         in  number,
    p_detail_grp         in  number
  ) return varchar2 is

l_exist   varchar2(1);

begin --- Main Begin

  l_exist :='N';

  if length(ltrim(rtrim(p_master_sku))) > 4 and
     length(ltrim(rtrim(p_detail_sku))) > 4 then

     begin
       select 'Y'
       into   l_exist
       from   sku_relations
       where  relation_type = 'CAS'
       and    sku = p_master_sku
       and    related_sku = p_detail_sku
       union
       select 'Y'
       from   sku_relations
       where  relation_type = 'CAS'
       and    sku = p_detail_sku
       and    related_sku = p_master_sku;
     exception
       when no_data_found then
         l_exist := 'N';
         return (l_exist);
     end;
  else
     begin
       select 'Y'
       into   l_exist
       from   sku_relations sr,
              groups g1,
              groups g2,
              skus s1,
              skus s2
       where  g1.grp = s1.grp
       and    g2.grp = s2.grp
       and    s1.sku = sr.sku
       and    s2.sku = sr.related_sku
       and    sr.relation_type = 'CAS'
       and    g1.grp = p_detail_grp
       and    g2.grp = p_master_grp
       union
       select 'Y'
       from   sku_relations sr,
              groups g1,
              groups g2,
              skus s1,
              skus s2
       where  g1.grp = s1.grp
       and  g2.grp = s2.grp
       and  s1.sku = sr.sku
       and  s2.sku = sr.related_sku
       and  sr.relation_type = 'CAS'
       and  g1.grp = p_master_grp
       and  g2.grp = p_detail_grp;
     exception
       when no_data_found then
         l_exist := 'N';
         return (l_exist);
     end;
   end if;
   return (l_exist);
exception
  when no_data_found then
    l_exist := 'N';
    return (l_exist);
end;

